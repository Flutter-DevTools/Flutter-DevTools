// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'page_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PageState<T, Tidle, Tloading, Tempty, Tfailure> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Tidle? data) idle,
    required TResult Function(Tloading? data) loading,
    required TResult Function(T data) loaded,
    required TResult Function(Tempty? data) empty,
    required TResult Function(Tfailure? data) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Tidle? data)? idle,
    TResult? Function(Tloading? data)? loading,
    TResult? Function(T data)? loaded,
    TResult? Function(Tempty? data)? empty,
    TResult? Function(Tfailure? data)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Tidle? data)? idle,
    TResult Function(Tloading? data)? loading,
    TResult Function(T data)? loaded,
    TResult Function(Tempty? data)? empty,
    TResult Function(Tfailure? data)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)
        idle,
    required TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)
        loading,
    required TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)
        loaded,
    required TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)
        empty,
    required TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)
        failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult? Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult? Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult? Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult? Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageStateCopyWith<T, Tidle, Tloading, Tempty, Tfailure, $Res> {
  factory $PageStateCopyWith(
          PageState<T, Tidle, Tloading, Tempty, Tfailure> value,
          $Res Function(PageState<T, Tidle, Tloading, Tempty, Tfailure>) then) =
      _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
          PageState<T, Tidle, Tloading, Tempty, Tfailure>>;
}

/// @nodoc
class _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
        $Val extends PageState<T, Tidle, Tloading, Tempty, Tfailure>>
    implements $PageStateCopyWith<T, Tidle, Tloading, Tempty, Tfailure, $Res> {
  _$PageStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_PageStateIdleCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
    $Res> {
  factory _$$_PageStateIdleCopyWith(
      _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value,
      $Res Function(_$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>)
          then) = __$$_PageStateIdleCopyWithImpl<T, Tidle, Tloading, Tempty,
      Tfailure, $Res>;
  @useResult
  $Res call({Tidle? data});
}

/// @nodoc
class __$$_PageStateIdleCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res>
    extends _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
        _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>>
    implements
        _$$_PageStateIdleCopyWith<T, Tidle, Tloading, Tempty, Tfailure, $Res> {
  __$$_PageStateIdleCopyWithImpl(
      _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> _value,
      $Res Function(_$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>(
      freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Tidle?,
    ));
  }
}

/// @nodoc

class _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>
    extends _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> {
  _$_PageStateIdle([this.data]) : super._();

  @override
  final Tidle? data;

  @override
  String toString() {
    return 'PageState<$T, $Tidle, $Tloading, $Tempty, $Tfailure>.idle(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PageStateIdleCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => __$$_PageStateIdleCopyWithImpl<T, Tidle, Tloading, Tempty,
              Tfailure, _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Tidle? data) idle,
    required TResult Function(Tloading? data) loading,
    required TResult Function(T data) loaded,
    required TResult Function(Tempty? data) empty,
    required TResult Function(Tfailure? data) failure,
  }) {
    return idle(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Tidle? data)? idle,
    TResult? Function(Tloading? data)? loading,
    TResult? Function(T data)? loaded,
    TResult? Function(Tempty? data)? empty,
    TResult? Function(Tfailure? data)? failure,
  }) {
    return idle?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Tidle? data)? idle,
    TResult Function(Tloading? data)? loading,
    TResult Function(T data)? loaded,
    TResult Function(Tempty? data)? empty,
    TResult Function(Tfailure? data)? failure,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)
        idle,
    required TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)
        loading,
    required TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)
        loaded,
    required TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)
        empty,
    required TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)
        failure,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult? Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult? Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult? Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult? Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>
    extends PageState<T, Tidle, Tloading, Tempty, Tfailure> {
  factory _PageStateIdle([final Tidle? data]) =
      _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>;
  _PageStateIdle._() : super._();

  Tidle? get data;
  @JsonKey(ignore: true)
  _$$_PageStateIdleCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PageStateLoadingCopyWith<T, Tidle, Tloading, Tempty,
    Tfailure, $Res> {
  factory _$$_PageStateLoadingCopyWith(
      _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value,
      $Res Function(_$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>)
          then) = __$$_PageStateLoadingCopyWithImpl<T, Tidle, Tloading, Tempty,
      Tfailure, $Res>;
  @useResult
  $Res call({Tloading? data});
}

/// @nodoc
class __$$_PageStateLoadingCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure,
        $Res>
    extends _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
        _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>>
    implements
        _$$_PageStateLoadingCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
            $Res> {
  __$$_PageStateLoadingCopyWithImpl(
      _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> _value,
      $Res Function(_$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>(
      freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Tloading?,
    ));
  }
}

/// @nodoc

class _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>
    extends _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> {
  _$_PageStateLoading([this.data]) : super._();

  @override
  final Tloading? data;

  @override
  String toString() {
    return 'PageState<$T, $Tidle, $Tloading, $Tempty, $Tfailure>.loading(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PageStateLoadingCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => __$$_PageStateLoadingCopyWithImpl<
              T,
              Tidle,
              Tloading,
              Tempty,
              Tfailure,
              _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Tidle? data) idle,
    required TResult Function(Tloading? data) loading,
    required TResult Function(T data) loaded,
    required TResult Function(Tempty? data) empty,
    required TResult Function(Tfailure? data) failure,
  }) {
    return loading(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Tidle? data)? idle,
    TResult? Function(Tloading? data)? loading,
    TResult? Function(T data)? loaded,
    TResult? Function(Tempty? data)? empty,
    TResult? Function(Tfailure? data)? failure,
  }) {
    return loading?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Tidle? data)? idle,
    TResult Function(Tloading? data)? loading,
    TResult Function(T data)? loaded,
    TResult Function(Tempty? data)? empty,
    TResult Function(Tfailure? data)? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)
        idle,
    required TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)
        loading,
    required TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)
        loaded,
    required TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)
        empty,
    required TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)
        failure,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult? Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult? Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult? Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult? Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>
    extends PageState<T, Tidle, Tloading, Tempty, Tfailure> {
  factory _PageStateLoading([final Tloading? data]) =
      _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>;
  _PageStateLoading._() : super._();

  Tloading? get data;
  @JsonKey(ignore: true)
  _$$_PageStateLoadingCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PageStateLoadedCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
    $Res> {
  factory _$$_PageStateLoadedCopyWith(
      _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value,
      $Res Function(_$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>)
          then) = __$$_PageStateLoadedCopyWithImpl<T, Tidle, Tloading, Tempty,
      Tfailure, $Res>;
  @useResult
  $Res call({T data});
}

/// @nodoc
class __$$_PageStateLoadedCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure,
        $Res>
    extends _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
        _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>>
    implements
        _$$_PageStateLoadedCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
            $Res> {
  __$$_PageStateLoadedCopyWithImpl(
      _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> _value,
      $Res Function(_$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>
    extends _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> {
  _$_PageStateLoaded({required this.data}) : super._();

  @override
  final T data;

  @override
  String toString() {
    return 'PageState<$T, $Tidle, $Tloading, $Tempty, $Tfailure>.loaded(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PageStateLoadedCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => __$$_PageStateLoadedCopyWithImpl<
              T,
              Tidle,
              Tloading,
              Tempty,
              Tfailure,
              _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Tidle? data) idle,
    required TResult Function(Tloading? data) loading,
    required TResult Function(T data) loaded,
    required TResult Function(Tempty? data) empty,
    required TResult Function(Tfailure? data) failure,
  }) {
    return loaded(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Tidle? data)? idle,
    TResult? Function(Tloading? data)? loading,
    TResult? Function(T data)? loaded,
    TResult? Function(Tempty? data)? empty,
    TResult? Function(Tfailure? data)? failure,
  }) {
    return loaded?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Tidle? data)? idle,
    TResult Function(Tloading? data)? loading,
    TResult Function(T data)? loaded,
    TResult Function(Tempty? data)? empty,
    TResult Function(Tfailure? data)? failure,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)
        idle,
    required TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)
        loading,
    required TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)
        loaded,
    required TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)
        empty,
    required TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)
        failure,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult? Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult? Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult? Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult? Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>
    extends PageState<T, Tidle, Tloading, Tempty, Tfailure> {
  factory _PageStateLoaded({required final T data}) =
      _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>;
  _PageStateLoaded._() : super._();

  T get data;
  @JsonKey(ignore: true)
  _$$_PageStateLoadedCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PageStateEmptyCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
    $Res> {
  factory _$$_PageStateEmptyCopyWith(
      _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value,
      $Res Function(_$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>)
          then) = __$$_PageStateEmptyCopyWithImpl<T, Tidle, Tloading, Tempty,
      Tfailure, $Res>;
  @useResult
  $Res call({Tempty? data});
}

/// @nodoc
class __$$_PageStateEmptyCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure,
        $Res>
    extends _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
        _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>>
    implements
        _$$_PageStateEmptyCopyWith<T, Tidle, Tloading, Tempty, Tfailure, $Res> {
  __$$_PageStateEmptyCopyWithImpl(
      _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> _value,
      $Res Function(_$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Tempty?,
    ));
  }
}

/// @nodoc

class _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>
    extends _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> {
  _$_PageStateEmpty({this.data}) : super._();

  @override
  final Tempty? data;

  @override
  String toString() {
    return 'PageState<$T, $Tidle, $Tloading, $Tempty, $Tfailure>.empty(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PageStateEmptyCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => __$$_PageStateEmptyCopyWithImpl<
              T,
              Tidle,
              Tloading,
              Tempty,
              Tfailure,
              _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Tidle? data) idle,
    required TResult Function(Tloading? data) loading,
    required TResult Function(T data) loaded,
    required TResult Function(Tempty? data) empty,
    required TResult Function(Tfailure? data) failure,
  }) {
    return empty(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Tidle? data)? idle,
    TResult? Function(Tloading? data)? loading,
    TResult? Function(T data)? loaded,
    TResult? Function(Tempty? data)? empty,
    TResult? Function(Tfailure? data)? failure,
  }) {
    return empty?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Tidle? data)? idle,
    TResult Function(Tloading? data)? loading,
    TResult Function(T data)? loaded,
    TResult Function(Tempty? data)? empty,
    TResult Function(Tfailure? data)? failure,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)
        idle,
    required TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)
        loading,
    required TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)
        loaded,
    required TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)
        empty,
    required TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)
        failure,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult? Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult? Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult? Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult? Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>
    extends PageState<T, Tidle, Tloading, Tempty, Tfailure> {
  factory _PageStateEmpty({final Tempty? data}) =
      _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>;
  _PageStateEmpty._() : super._();

  Tempty? get data;
  @JsonKey(ignore: true)
  _$$_PageStateEmptyCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PageStateFailureCopyWith<T, Tidle, Tloading, Tempty,
    Tfailure, $Res> {
  factory _$$_PageStateFailureCopyWith(
      _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value,
      $Res Function(_$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>)
          then) = __$$_PageStateFailureCopyWithImpl<T, Tidle, Tloading, Tempty,
      Tfailure, $Res>;
  @useResult
  $Res call({Tfailure? data});
}

/// @nodoc
class __$$_PageStateFailureCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure,
        $Res>
    extends _$PageStateCopyWithImpl<T, Tidle, Tloading, Tempty, Tfailure, $Res,
        _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>>
    implements
        _$$_PageStateFailureCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
            $Res> {
  __$$_PageStateFailureCopyWithImpl(
      _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> _value,
      $Res Function(_$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>(
      freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Tfailure?,
    ));
  }
}

/// @nodoc

class _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>
    extends _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> {
  _$_PageStateFailure([this.data]) : super._();

  @override
  final Tfailure? data;

  @override
  String toString() {
    return 'PageState<$T, $Tidle, $Tloading, $Tempty, $Tfailure>.failure(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PageStateFailureCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => __$$_PageStateFailureCopyWithImpl<
              T,
              Tidle,
              Tloading,
              Tempty,
              Tfailure,
              _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Tidle? data) idle,
    required TResult Function(Tloading? data) loading,
    required TResult Function(T data) loaded,
    required TResult Function(Tempty? data) empty,
    required TResult Function(Tfailure? data) failure,
  }) {
    return failure(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Tidle? data)? idle,
    TResult? Function(Tloading? data)? loading,
    TResult? Function(T data)? loaded,
    TResult? Function(Tempty? data)? empty,
    TResult? Function(Tfailure? data)? failure,
  }) {
    return failure?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Tidle? data)? idle,
    TResult Function(Tloading? data)? loading,
    TResult Function(T data)? loaded,
    TResult Function(Tempty? data)? empty,
    TResult Function(Tfailure? data)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)
        idle,
    required TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)
        loading,
    required TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)
        loaded,
    required TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)
        empty,
    required TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)
        failure,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult? Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult? Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult? Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult? Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _PageStateIdle<T, Tidle, Tloading, Tempty, Tfailure> value)?
        idle,
    TResult Function(
            _PageStateLoading<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loading,
    TResult Function(
            _PageStateLoaded<T, Tidle, Tloading, Tempty, Tfailure> value)?
        loaded,
    TResult Function(
            _PageStateEmpty<T, Tidle, Tloading, Tempty, Tfailure> value)?
        empty,
    TResult Function(
            _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure> value)?
        failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class _PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>
    extends PageState<T, Tidle, Tloading, Tempty, Tfailure> {
  factory _PageStateFailure([final Tfailure? data]) =
      _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>;
  _PageStateFailure._() : super._();

  Tfailure? get data;
  @JsonKey(ignore: true)
  _$$_PageStateFailureCopyWith<T, Tidle, Tloading, Tempty, Tfailure,
          _$_PageStateFailure<T, Tidle, Tloading, Tempty, Tfailure>>
      get copyWith => throw _privateConstructorUsedError;
}
